# -*- coding: utf-8 -*-
"""FEM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JyhbiCgbF1XiJGz6d7-MwJQDDw180Lzi
"""

#Inputs

'''
EV: EV requests - {Ps,Pd,Tr,delt,SOCcurr,SOCreq} at random times
TPM: Network topology to apply djikstra - {graph(with i,jth entry indicating dij distance between node i and j), traffic matrix(with i,jth entry indicating vij velocity between node i and j)}
CPM: nothing
EVCS: No of EV requests, no of charging cars, no of waiting cars for all k EVCSs
'''


#Outputs

'''
As soon as the car sends a charging request (at time t), we have to process and feed the following to the DQN as input (at time t)->
CRt = {Ps, Pd, Tr, delt, SOCcurr, SOCreq}
ATt = {Tarr1,....Tarrk} <- djikstra + Tr
WTt = {Tw1,....Twk} <- CPM algo (Gowtham)
DTt = {Tdrive1,....Tdrivek} <- djikstra
Dt = {dw1,....dwk} <- djikstra
'''

import classes
'''import EV, EVCS, TPM'''
#Utility functions
from collections import deque
import random
import sys
import numpy as np

def minDistance(dist, sptSet, V=39):
        mini = sys.maxsize
        min_index = 0
        for u in range(V):
            if dist[u] < mini and sptSet[u] == False:
                mini = dist[u]
                min_index = u
        return min_index


# g is time graph
# g2 is distance graph
def djikstra(g,start_node,final_node,V=39):
        dist = [sys.maxsize] * (V)
        dist[start_node] = 0
        sptSet = [False] * V
        for cout in range(V):
            x = minDistance(dist, sptSet,39)
            sptSet[x] = True
            for y in range(V):
                if g[x][y] > 0 and sptSet[y] == False and dist[y] > dist[x] + g[x][y]:
                    dist[y] = dist[x] + g[x][y]
        
        #print(dist)
        #print(final_node)
        return dist[final_node]
    
def djikstra_with_path(g, start_node, final_node, V=39):
    dist = [sys.maxsize] * V
    dist[start_node] = 0
    sptSet = [False] * V
    predecessor = [-1] * V  # To store the predecessor of each node

    for _ in range(V):
        x = minDistance(dist, sptSet, V)
        sptSet[x] = True
        for y in range(V):
            if (g[x][y] > 0 and sptSet[y] == False and
                    dist[y] > dist[x] + g[x][y]):
                dist[y] = dist[x] + g[x][y]
                predecessor[y] = x  # Update predecessor of y

    # Constructing the path from start_node to final_node
    path = []
    current_node = final_node
    while current_node != -1:  # Until we reach the start_node
        path.insert(0, current_node)
        current_node = predecessor[current_node]

    return dist[final_node], path
    
def djikstra_rand(graph,start_node,end_node):
    visited = set()
    path = []
    def dfs(node):
        visited.add(node)
        path.append(node)
        
        if node == end_node:
            return True
        
        neighbors = [(i, weight) for i, weight in enumerate(graph[node]) if weight != 1000000 and i not in visited]
        random.shuffle(neighbors)
        
        for neighbor, weight in neighbors:
            if dfs(neighbor):
                return True
        
        path.pop()
        return False
    
    if dfs(start_node):
        summ = 0
        for i in range(len(path)-1):
            summ += graph[path[i]][path[i+1]]
        return summ
    else:
        return None
            

        
    
def get_expected_waiting_times(ev, charging_stations):
  wt_list = []
  for evcs in charging_stations:
    wt_list.append(0.75*evcs.waiting_time(ev))
  return wt_list

def get_arrival_times(global_request_time,start_node,charging_stations,g,k):
    arrival_times = [0]*k
    for i in range(k):
        arrival_times[i] = global_request_time + djikstra(g,start_node,charging_stations[i],39)
    return arrival_times

def get_driving_times(start_node,charging_stations,g,k,end_node):
    driving_times = [0]*k
    for i in range(k):
        driving_times[i] = 0.75*(djikstra(g,start_node,charging_stations[i],39) + djikstra(g,charging_stations[i],end_node,39))
    return driving_times

def get_driving_distances(start_node,charging_stations,g2,k):
    driving_distance = [0]*k
    for i in range(k):
        #print(i)
        driving_distance[i] = djikstra(g2,start_node,charging_stations[i],39)
    return driving_distance

def preprocess_data(ev,ev_request,charging_stations,Map,time_matrix,charging_stations_info,k=3):
    state = []
    for i in ev_request:
        state.append(i)
    for i in get_arrival_times(ev_request[2],ev_request[0],charging_stations,time_matrix,k):
        state.append(i)
    for i in get_expected_waiting_times(ev,charging_stations_info):
        state.append(i)
    for i in get_driving_times(ev_request[0],charging_stations,time_matrix,k,ev_request[1]):
        state.append(i)
    for i in get_driving_distances(ev_request[0],charging_stations,Map.distance_matrix,k):
        state.append(i)
    state = np.array(state)
    return state

def get_travel_costs(ev_request,charging_stations,state,g2,action,k=3):
  SOC_arrival = [0]*k
  Ech = [0]*k
  travel_costs = [0]*k
  charging_times = [0]*k
  for i in range(k):
    SOC_arrival[i] = ev_request[4] - (0.16*djikstra(g2,ev_request[0],charging_stations[i],39))/57.75
    Ech[i] = (ev_request[5] - SOC_arrival[i]) * 57.75
    charging_times[i] = Ech[i]/(60*0.9)
    charging_times[i] = 0.75*charging_times[i] + 0.84783*Ech[i]
    travel_costs[i] = charging_times[i] + state[12+i] + state[9+i]
    #print(state[9+i])
  return travel_costs

def get_distance_costs(ev_request,charging_stations,g2,k=3):
  phi = 0.5
  start_node = ev_request[0]
  end_node = ev_request[1]
  distance_cost = [0]*k
  for i in range(k):
      distance_cost[i] = phi*(djikstra(g2,start_node,charging_stations[i],39) + djikstra(g2,charging_stations[i],end_node,39) - djikstra(g2,start_node,end_node,39)) 
  return distance_cost

def get_distance_cost(ev_request,charging_stations,g2,action,k=3):
  phi = 0.5
  start_node = ev_request[0]
  end_node = ev_request[1]
  distance_cost = phi*(djikstra(g2,start_node,charging_stations[action],39) + djikstra(g2,charging_stations[action],end_node,39) - djikstra(g2,start_node,end_node,39)) 
  return distance_cost

def get_actual_distance(ev_request,charging_stations,g2,action,k=3):
  phi = 0.5
  start_node = ev_request[0]
  end_node = ev_request[1]
  distance_cost = phi*(djikstra_rand(g2,start_node,charging_stations[action]) + djikstra_rand(g2,charging_stations[action],end_node) - djikstra_rand(g2,start_node,end_node)) 
  return distance_cost


def get_charging_costs(ev_request,charging_stations,state,g2,k=3):
  SOC_arrival = [0]*k
  Ech = [0]*k
  charging_times = [0]*k
  for i in range(k):
    SOC_arrival[i] = ev_request[4] - (0.16*djikstra(g2,ev_request[0],charging_stations[i],39))/57.75
    Ech[i] = (ev_request[5] - SOC_arrival[i]) * 57.75
    charging_times[i] = Ech[i]/(60*0.9)
    charging_times[i] = 0.75*charging_times[i] + 0.84783*Ech[i]
    #print(state[9+i])
  return charging_times

def get_travel_times(ev_request,charging_stations,state,g2,k=3):
  SOC_arrival = [0]*k
  Ech = [0]*k
  travel_times = [0]*k
  charging_times = [0]*k
  for i in range(k):
    SOC_arrival[i] = ev_request[4] - (0.16*djikstra(g2,ev_request[0],charging_stations[i],39))/57.75
    Ech[i] = (ev_request[5] - SOC_arrival[i]) * 57.75
    charging_times[i] = Ech[i]/(60*0.9)
    travel_times[i] = charging_times[i] + ((state[12+i] + state[9+i])/0.75)
    #print(state[9+i])
  return travel_times

def get_total_distances(ev_request,charging_stations,g2,k=3):
  travel_distance = [0]*k
  start_node = ev_request[0]
  end_node = ev_request[1]
  for i in range(k):
    travel_distance[i] = djikstra(g2,start_node,charging_stations[i],39) + djikstra(g2,charging_stations[i],end_node,39) 
    #print(state[9+i])
  return travel_distance
        

def get_actual_costs(ev_request,charging_stations,state,g,g2,station_to_go,action,k=3):
  SOC_arrival = [0]*k
  Ech = [0]*k
  charging_times = [0]*k
  for i in range(k):
    SOC_arrival[i] = ev_request[4] - (0.16*djikstra(g2,ev_request[0],charging_stations[i],39))/57.75
    Ech[i] = (ev_request[5] - SOC_arrival[i]) * 57.75
    charging_times[i] = Ech[i]/(60*0.9)
    charging_times[i] = 0.75*charging_times[i] + 0.84783*Ech[i]
  return state[9+action] + charging_times[action] + 0.75*(djikstra_rand(g,ev_request[0],station_to_go) + djikstra_rand(g, station_to_go, ev_request[1]))
        

